# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.

from datetime import datetime, timezone
import os
from typing import List, Optional

from .base import StorageAdapterBase


ROOT_PATH = os.path.dirname(os.path.abspath(__file__))
RESOURCES_PATH = os.path.join(ROOT_PATH, '..', '..', 'resources')


class ResourceAdapter(StorageAdapterBase):
    """Resource storage adapter"""

    def __init__(self, root: Optional[str] = RESOURCES_PATH) -> None:
        """The constructor can have a specified root for resources (used by internal code mostly, but can be used for external),
         by default it finds resources for a wheel generated by setuptools."""
        self.root = os.path.abspath(root)  # type: str
        self.location_hint = None  # type: Optional[str]
        self._type = 'resource'

    def can_read(self) -> bool:
        return True

    def can_write(self) -> bool:
        return False

    async def read_async(self, corpus_path: str) -> str:
        adapter_path = self.create_adapter_path(corpus_path)

        with open(adapter_path, 'r', encoding='utf-8') as file:
            return file.read()

    async def write_async(self, corpus_path: str, data: str) -> None:
        raise NotImplementedError()

    def create_adapter_path(self, corpus_path: str) -> str:
        if not corpus_path:
            return None

        corpus_path = corpus_path[(corpus_path.find(':') + 1):].lstrip('\\/')

        return os.path.join(self.root, corpus_path)

    def create_corpus_path(self, adapter_path: str) -> Optional[str]:
        if adapter_path and not adapter_path.startswith('http'):
            normalized_adapter_path = os.path.abspath(adapter_path).replace('\\', '/')
            normalized_root = self.root.replace('\\', '/')

            if normalized_adapter_path.startswith(normalized_root):
                return normalized_adapter_path[len(normalized_root):]

        # Signal that we did not recognize path as one for self adapter.
        return None

    def clear_cache(self) -> None:
        pass

    async def compute_last_modified_time_async(self, corpus_path: str) -> Optional[datetime]:
        return datetime.now(timezone.utc)

    async def fetch_all_files_async(self, folder_corpus_path: str) -> List[str]:
        return None

    def fetch_config(self) -> str:
        raise NotImplementedError()

    def update_config(self, config: str) -> None:
        raise NotImplementedError()
